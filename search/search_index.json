{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":""},{"location":"#welcome-to-the-mpython-control-board","title":"Welcome to the mPython Control Board","text":"<p>The mPython Control Board integrates the high-performance ESP32 dual-core chip into a user-friendly MicroPython microcontroller board. Using the popular Python programming language, this board simplifies transferring code from your computer, letting you dive into the exciting world of programming creation effortlessly!</p>"},{"location":"#why-python","title":"Why Python?","text":"<p>Python is one of the fastest-growing programming languages globally. It's simple enough for educational purposes yet robust enough to power major web services like Instagram, Spotify, and Netflix. Python's influence is expanding into the realm of physical computing, where it is increasingly chosen over traditional languages like C, C++, and Arduino. Today, over 130 microcontroller boards, including the original Pyboard, various Adafruit boards, and five Arduinos, support Python programming.</p>"},{"location":"#python-vs-c-which-to-learn","title":"Python vs. C++: Which to Learn?","text":"<p>New programmers often wonder whether to start with Python or C++. While there's no definitive answer, Python offers several advantages:</p> <ul> <li> <p>User-Friendliness: Python code is clean and readable, using indentation rather than semicolons and curly braces to define code blocks. Simplified Memory Management: As an interpreted language, Python handles memory management for you, eliminating the need to declare data types or manage memory directly. Rapid Prototyping: Python allows for immediate code execution without the compile-and-flash steps required by languages like C++. MicroPython: The Power of Python on Microcontrollers</p> </li> <li> <p>MicroPython, created by Damien George, brings Python's simplicity and efficiency to hardware programming. Initially developed for the STM32 chip, it's now widely used in devices like the BBC micro:bit and ESP32. MicroPython features its own interpreter, making programming more accessible and enjoyable, especially with the interactive REPL environment.</p> </li> </ul>"},{"location":"#stay-tuned","title":"Stay Tuned...","text":"<p>Explore more about how Python is revolutionizing hardware programming and stay updated with new features and capabilities of the mPython Control Board!</p>"},{"location":"#technical-parameters","title":"Technical Parameters","text":"Technical Parameters Specifications Processor Tensilica LX6 dual-core processor (one core handles high-speed connections; one core handles independent application development) Main frequency Up to 240MHz clock frequency SRAM 520KB Flash 8MB Wi-Fi standards FCC/CE/TELEC/KCC Wi-Fi protocol 802.11 b/g/n/d/e/i/k/r (802.11n, speed up to 150 Mbps), A-MPDU and A-MSDU aggregation, support 0.4us guard interval Frequency range 2.4~2.5 GHz Bluetooth protocol Compliant with Bluetooth v4.2 BR/EDR and BLE standards Bluetooth audio CVSD and SBC audio Low power consumption: 10uA Power supply mode USB power supply; external power supply; Working voltage 3.3V Maximum operating current 200mA Maximum load current 1000mA Take control of the board Three-axis accelerometer MSA300 Measuring range: \u00b12/4/8/16G; Six-axis sensor (v2.1.0 and later) QMI8658C (LGA-14) gyroscope: optional range, up to \u00b12048\u00b0/s Three-axis accelerometer: optional range, up to \u00b116G; Geomagnetic sensor MMC5983MA Measuring range: \u00b18G range; accuracy 0.4mGs, electronic compass error \u00b10.5\u00b0; Geomagnetic sensor MMC5603NJ (v2.2.0 and later versions) 3-axis, minimum resolution is 0.0625mG, \u00b130G range, pointing accuracy within \u00b11\u00b0; Light sensor Phototransistor ALS-PT19-315C Microphone EM4013BTC1R16B-T0-423 3 full-color WS2812-2020 RGB-LED lamp beads 1.3-inch OLED display Supports 16*16 character display, resolution 128x64 Passive buzzer SMD-050020F-03040N Supports buttons 2 physical buttons (A/B) and 6 touch buttons (P/Y/T/H/O/N) Supports interface 1-way alligator clip interface, which can easily connect to various resistive sensors Expand interface Digital I/O channels 20 channels (supporting 12 channels of PWM and 6 channels of touch input) Analog input ADC 5-channel 12-bit analog input ADC, P0~P4 External input alligator clip interface EXT/GND Communication protocols supported I2C, UART, SPI"},{"location":"advancedtutorial/","title":"Advanced Tutorial","text":""},{"location":"advancedtutorial/#1-random-numbers","title":"1. Random Numbers","text":"<p>Sometimes we need to do something random or generate random numbers. At this time, you can use the <code>random</code> module.</p> <p>For example, here's how to randomly display names on an OLED display:</p> <pre><code>from mpython import *\nimport random\n\nnames = [\"Mary\", \"Yolanda\", \"Damien\", \"Alia\", \"Kushal\", \"Mei Xiu\", \"Zoltan\"]\n\noled.DispChar(random.choice(names), 40, 20)\noled.show()\noled.fill(0)\n</code></pre> <p>The list (names) contains seven names defined as strings. The random.choice method takes a list of names as a parameter and returns a randomly selected item.</p> <p>Can you modify the list to include your own name?</p>"},{"location":"advancedtutorial/#11-display-numbers-randomly","title":"1.1. Display Numbers Randomly","text":"<p>Random numbers are very useful. They are very common in the game. Why do we still have dice?</p> <p>MicroPython comes with several useful random number methods. Here's how to make a simple dice:</p> <pre><code>from mpython import *\nimport random\n\noled.DispChar(str(random.randint(1, 6)), 60, 20)\noled.show()\noled.fill(0)\n</code></pre> <p>Every time the dashboard is restarted, it will display a number between 1 and 6. randint() returns an integer, we need to use str() to convert the integer into a string (for example, 6 -&gt; \"6\"). oled.DispChar() writes random numbers to oled.</p> <p>If you want to set a random range or increasing base, you can use random.randrange():</p> <pre><code>from mpython import *\nimport random\n\noled.DispChar(str(random.randrange(0, 10, 2)), 60, 20)\noled.show()\noled.fill(0)\n</code></pre> <p>random.randrange(start, end, step). start is the starting value of the random number, end is the ending value of the random number, and step is the increasing base. The above example randomly displays even numbers in the range (0,10).</p> <p>Sometimes you need numbers with decimal points. You can use random.random() to generate a random floating point number from 0.0 to 1.0. If you need the result of adding larger random floating point numbers use random.uniform():</p> <pre><code>from mpython import *\nimport random\n\noled.DispChar(str(random.random()), 30, 10)\noled.DispChar(str(random.uniform(1, 20)), 30, 30)\noled.show()\noled.fill(0)\n</code></pre>"},{"location":"advancedtutorial/#12-random-seeds","title":"1.2. Random Seeds","text":"<p>The random number in MicroPython is actually a stable sequence of results obtained by a stable algorithm, not a random sequence. The seed is the first value that the algorithm starts calculating. So it will appear that as long as the seed is the same, all subsequent \"random\" results and sequences will be exactly the same.</p> <p>Specify a random number seed, usually used in conjunction with other random number generation functions</p> <p>Sometimes you want to have repeatable random behavior: a reproducible source of randomness. It's like saying you need the same five random values every time you roll a die.</p> <p>Example:</p> <pre><code>import random\nfrom mpython import *\n\nfor i in range(0, 2):\n    random.seed(8)\n\n    for j in range(8):\n        oled.DispChar(str(random.randint(1, 10)), j * 16, i * 16)\n        oled.show()\n        print(random.randint(1, 10))\n\noled.fill(0)\n</code></pre>"},{"location":"advancedtutorial/#13-falling-snow-effect","title":"1.3. Falling Snow Effect","text":"<p>Combined with the random number generation learned above, we can use the control panel OLED screen to create the effect of falling snowflakes.</p> <pre><code>from mpython import *\nfrom random import randint\n\nclass snow():\n    def __init__(self):                \n        self.x = randint(0, 127)         # Randomly generate the starting coordinate point of the snowflake\n        self.y = randint(0, 10)\n        self.r = randint(1, 2)           # Randomly generate the size of the snowflake radius\n        self.vx = randint(-2, 2)         # Randomly generate the x,y movement path of the snowflake\n        self.vy = randint(1, 3)         \n\n    def refresh(self):                 \n        self.x += self.vx               # Move the coordinate down, snowflake falls\n        self.y += self.vy\n        if self.x &gt; 128 or self.x &lt; 0:\n            self.x = randint(0, 127)\n        if self.y &gt; 63 or self.y &lt; 0:\n            self.y = 0\n\n    def run(self):\n        self.refresh()\n        oled.fill_circle(self.x, self.y, self.r, 1)     # Draw the snowflake\nballs = []\nfor x in range(20):              # Generate 20 snowflake points\n    balls.append(snow())        \nwhile True:\n    sleep_ms(50)                 # Refresh time\n    oled.fill(0)                 # Clear the screen\n    for b in balls:              # Snowflake falls\n        b.run()\n    oled.show()                  # Display OLED\n</code></pre>"},{"location":"advancedtutorial/#2-save","title":"2. Save","text":"<p>Sometimes you need to store useful information. This information is stored as data: a representation of the information (in digital form when stored on a computer). If you store data on your computer, it should remain even if you turn the device off and on again.</p> <p>The microPython bit allows you to do this using a very simple file system.</p>"},{"location":"advancedtutorial/#what-is-a-file-system","title":"What is a file system?","text":"<p>It is a method of storing and organizing data in a persistent manner - any data stored in the file system should survive device restarts. As the name suggests, data stored in a file system is organized into files.</p> <p>Computer files are named digital resources stored on a file system. These resources contain useful information as data. This is exactly how paper documents work. It is a named container that contains useful information. Often, paper and digital files are named to indicate what they contain. On computers, files are usually ended with a suffix like <code>.txt</code> for text files, <code>.jpg</code> for JPEG images, and <code>.mp3</code> for sound data encoded as MP3.</p> <p>Some file systems, such as those on your laptop or PC, allow you to organize files into directories: named containers that group related files and subdirectories together. However, the file system provided by MicroPython is a flat file system. Flat file systems have no directories - all files are stored in just one place.</p> <p>The Python programming language contains an easy-to-use and powerful way to work with your computer's file system. MicroPython on mPython implements a useful subset of these features, making it easy to read and write files on the device, while also providing consistency with other Python versions.</p>"},{"location":"advancedtutorial/#21-open-the-file","title":"2.1. Open the file","text":"<p>The following are relevant operation instructions for Python File operations.</p> <pre><code>open(path+filename, mode), e.g., f = open('/tmp/hello', 'w')\n</code></pre>"},{"location":"blockcoding/","title":"Blockcoding","text":"<p>show</p> <p>oled.DispChar() Description: OLED screen displays text</p>"},{"location":"gettingstarted/","title":"Getting Started","text":""},{"location":"gettingstarted/#getting-started","title":"Getting Started","text":"<p>Download Software  </p>"},{"location":"gettingstarted/#1-repl","title":"1. REPL","text":"<p>One of the main advantages of using MicroPython is the interactive REPL. </p> <p>REPL stands for read-evaluate-output loop. REPL is a great help for learning a new programming language because it can respond immediately to programs written by beginners, which means you can execute the code and see the results immediately without having to compile and upload it first. Cumbersome steps</p>"},{"location":"gettingstarted/#11serial-port-connection","title":"1.1.Serial port connection","text":"<p>To access via USB-serial, you need to use serial terminal software.</p> <p>Set the serial port baud rate to 115200 and you can start playing MicroPython.</p> <p>Once the connection is established through the serial port, you can test whether it is working properly by pressing the Enter key a few times. If it is working, you will be able to see the Python REPL prompt, represented by &gt;&gt;&gt;.</p>"},{"location":"gettingstarted/#12-using-repl","title":"1.2. Using REPL","text":"<p>Once you're prompted, you're ready to try it! After pressing the Enter key, you can type anything at the prompt. MicroPython will run the code you enter and print the results (if any); if there is an error in the entered text, an error message will be printed.</p> <p>Try typing the following at the prompt:</p> <pre><code>print('hello mPython')\nhello mPython\n</code></pre> <p>Note that you do not need to type &gt;&gt;&gt;the arrows, they indicate that you should type text after this prompt and the next line will be the content of the response.</p> <p>If you already know some python, you can now try some basic commands. For example:</p> <p>You can try downloading mPython to display characters on an OLED display:</p> <p><pre><code>from mpython import *\noled.DispChar('hello,world!',0,0)\noled.show()\n</code></pre> In block code , </p> <p>oled.DispChar(str,x,y) stris the string to be displayed, xand , yare the x and y coordinates of the display starting point. Then oled.show()after refreshing the screen with , the string can be displayed on the OLED display. You can try displaying arbitrary strings elsewhere.</p>"},{"location":"gettingstarted/#121-line-editing","title":"1.2.1. Line editing","text":"<p>You can use the left and right arrow keys to move the cursor to edit the currently entered line; press the Home key or ctrl-A to move the cursor to the beginning of the line, and press End or ctrl-E to move to the end of the line; the Delete key or Escape The space key is used to delete.</p>"},{"location":"gettingstarted/#122input-history","title":"1.2.2.Input history","text":"<p>The REPL remembers a certain number of the first few lines of text you enter (up to 8 lines on ESP32). To recall the previous line, use the up and down arrow keys.</p>"},{"location":"gettingstarted/#123-tab-key","title":"1.2.3. Tab key","text":"<p>Tab key to view a list of all members in the module. This is useful for finding out what functions and methods a module or object has. Assuming you imported machine in the above example then type .and press Tab to see a list of all members of the machine module: machine.</p> class name ADC DAC DEEPSLEEP DEEPSLEEP_RESET EXT0_WAKE EXT1_WAKE HARD_RESET I2C PIN_WAKE PWM PWRON_RESET Pin RTC SLEEP SOFT_RESET SPI Signal TIMER_WAKE TOUCHPAD_WAKE Timer TouchPad UART ULP_WAKE WDT WDT_RESET deepsleep disable_irq enable_irq freq idle mem16 mem32 mem8 reset reset_cause sleep time_pulse_us unique_id wake_reason machine."},{"location":"gettingstarted/#124-line-continuation-and-automatic-indentation","title":"1.2.4. Line continuation and automatic indentation","text":"<p>Some of what you type will need to \"continue\", that is, more lines of text will be needed to generate a correct Python statement. In this case, the prompt will change to <code>...</code> and the cursor will automatically indent the correct amount so that you can immediately start typing the next line. Try this by defining the following function:</p> <pre><code>def toggle(p):\n   p.value(not p.value())\n</code></pre> <p>Above, you need to press the Enter key three times in a row to complete the compound statement (i.e. three lines with just dots). Another way to complete a compound statement is to press the backspace key to get to the beginning of the line and then press the Enter key. (If you make a mistake and want to exit, press ctrl-C and all lines will be ignored.)</p> <p>You just defined the function to flip the pin level. The pin object you created earlier should still exist (if not, you'll need to recreate it) and you can flip the LED using:</p> <p>toggle(pin)</p> <p>Now let's toggle the LED in a loop (if you don't have an LED, then you can print some text instead of calling toggle and see the effect):</p> <pre><code>import time\nwhile True:\n    toggle(pin)\n    time.sleep_ms(500)\n</code></pre> <p>This will flip the LED at 1Hz (half a second on, half a second off). To stop the toggle press ctrl-C, this will raise a keyboard interrupt exception and exit the loop.</p>"},{"location":"gettingstarted/#125paste-mode","title":"1.2.5.Paste mode","text":"<p>Pressing ctrl-E will enter special paste mode, which allows you to copy and paste a large block of text into the REPL. If you press ctrl-E you will see the paste mode prompt:</p> <p>paste mode; Ctrl-C to cancel, Ctrl-D to finish</p> <p>You can then paste (or type) your text. Note that there are no special keys or commands that work in paste mode (such as Tab or Backspace), they are just accepted as-is. Press ctrl-D to finish entering text and execute.</p>"},{"location":"gettingstarted/#2display","title":"2.Display","text":"<p>The control board has an onboard 1.3-inch OLED display with a resolution of 128x64.</p>"},{"location":"gettingstarted/#21-text-display","title":"2.1 Text Display","text":"<p>To display text, first import the <code>mpython</code> module:</p> <pre><code>from mpython import *\n</code></pre> <pre><code># To visualize how characters are displayed on the screen, choose pixel inversion mode\noled.DispChar('hello, world!',0,0,mode=TextMode.rev)\n# By default, the background pixels are turned off\noled.DispChar('hello, world!',0,16,mode=TextMode.normal)\noled.show()\n</code></pre> <p>The DispChar(str,x,y) function writes text content into the FrameBuffer. x and y are the starting xy coordinates for the OLED. oled.show() refreshes the screen.</p> <p>To display  \"hello, world\" text:</p> <p> <pre><code>oled.DispChar('hello, world', 32, 16)\n</code></pre></p>"},{"location":"gettingstarted/#22-basic-shape-drawing","title":"2.2 Basic Shape Drawing","text":"<p>Example: Drawing lines</p> <pre><code>Copy code\ndef testdrawline():\n    for i in range(0,64):\n        oled.line(0,0,i*2,63,1)\n        oled.show()\n    # Other line drawing code...\n\n\nDisplay Pictures\n``` python\nCopy code\n# Load bitmap data\nbmp = bytearray([...])  # Bitmap data array\noled.bitmap(0, 0, bmp, 128, 64, 1)\noled.show()\n</code></pre>"},{"location":"gettingstarted/#23-dynamic-display","title":"2.3 Dynamic Display","text":"<pre><code>images = []\nfor n in range(1,7):\n    with open('scatman.%s.pbm' % n, 'rb') as f:\n        f.readline() # Magic number\n        f.readline() # Creator comment\n        f.readline() # Dimensions\n        data = bytearray(f.read())\n    fbuf = framebuf.FrameBuffer(data, 128, 64, framebuf.MONO_HLSB)\n    images.append(fbuf)\n</code></pre> <pre><code>oled.invert(1)\nwhile True:\n    for i in images:\n        oled.blit(i, 0, 0)\n        oled.show()\n        time.sleep(0.1)\n</code></pre> <p>For more detailed information on OLED display operations and shape drawing, please refer to bitandbrick tutorials</p>"},{"location":"gettingstarted/#3-rgb-led","title":"3. RGB LED","text":"<p>mPython controls three onboard WS2812 lamp beads. WS2812 is a low-power RGB three-color lamp integrated with a current control chip. It can achieve 256 levels of brightness display and complete true color display of 16,777,216 colors. It uses a special single-line communication method to control the color of RGB lights, which is easy to use.</p>"},{"location":"gettingstarted/#31-onboard-rgb-led","title":"3.1 Onboard RGB LED","text":""},{"location":"gettingstarted/#example-light-up-rgb-led","title":"Example: Light up RGB LED","text":"<pre><code>from mpython import *\nrgb[0] = (255, 0, 0)  # Set to red, full brightness\nrgb[1] = (0, 128, 0)  # Set to green, half brightness\nrgb[2] = (0, 0, 64)   # Set to blue, quarter brightness\nrgb.write()\n</code></pre> <p>First import the mpython module:</p> <p>from mpython import *</p> <p>After importing the mpython module, a NeoPixel object rgb will be created for control. To control the onboard RGB, you only need to operate on the rgb object.</p> <p>Set color:</p> <pre><code>rgb[0] = (255, 0, 0)  # Set to red, full brightness\nrgb[1] = (0, 128, 0)  # Set to green, half brightness\nrgb[2] = (0, 0, 64)   # Set to blue, quarter brightness\n</code></pre> <p>rgb[n] = (r, g, b) can set the color of each pixel, n which is the number of onboard RGB lights. The first light is 0. r, g, b are the color brightness values, and the range is 0~255.</p> <p>rgb.fill(rgb_buf) can fill the color of all pixels, such as: rgb.fill((255,0,0)), all RGB lights are set to red, full brightness.</p> <p>Output color to RGB light</p> <p>rgb.write()</p>"},{"location":"gettingstarted/#32-external-ribbons","title":"3.2 External ribbons","text":"<p>Example: Light up the external ribbon</p> <p>from mpython import * import neopixel</p> <p>np = neopixel.NeoPixel(Pin(Pin.P15), n=24, bpp=3, timing=1)</p>"},{"location":"gettingstarted/#functions-for-creating-effects","title":"Functions for creating effects...","text":"<p>If you need to use an external ribbon, you must first create a neopixel object, define the parameters pin, and then control the LED on the ribbon through the object. For more detailed usage, please refer to the neopixel module.</p> <p>Hint: mPyhton provides an enhanced version of the neopixel module, which is encapsulated with richer neopixel display effects and is easy to operate. For detailed instructions, please visit bitandbrick tutorials</p>"}]}